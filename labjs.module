<?php

/**
 * @file
 *   LABjs module
 */

define('LABJS_EXCLUDE', '// LABjs exclusion');

/**
 * Implements hook_init().
 */
function labjs_init() {
  // Loads our loader first
  // Normally we use JS_LIBRARY, but Google Analytics module uses JS_LIBRARY-1,
  // then we use JS_LIBRARY-10. We should look for a more proper approach.
  drupal_add_js(labjs_get_path(), array(
    'group' => JS_LIBRARY,
    'every_page' => 1,
    'preprocess' => FALSE,
    'inline' => TRUE,
  ));

  drupal_add_js(labjs_get_jquery_hold_ready_path(), array(
    'group' => JS_LIBRARY,
    'every_page' => 1,
  ));

  if (module_exists('advagg')) {
    // Add in LAB.js init function.
    drupal_add_js(LABJS_EXCLUDE . "\nvar \$L = \$L || \$LAB.setGlobalDefaults({AlwaysPreserveOrder:true, AllowDuplicates:false});", array(
      'group' => JS_LIBRARY-10,
      'weight' => -49,
      'every_page' => 1,
      'type' => 'inline',
      'movable' => FALSE,
    ));

    // Makes Google Analytics work.
    drupal_add_js(LABJS_EXCLUDE . "\n" . '$L = $L.wait(function() {Drupal.scriptsready=true;jQuery(document).trigger("scripts-ready");});', array(
      'group' => JS_THEME+101,
      'weight' => 20,
      'every_page' => 1,
      'type' => 'inline',
      'scope' => 'footer',
      'movable' => FALSE,
    ));
  }
}

/**
 * Implements hook_menu().
 */
function labjs_menu() {
  $items = array();
  $file_path = drupal_get_path('module', 'labjs') . '/includes';

  $items['admin/config/development/labjs'] = array(
    'title' => 'LABjs',
    'description' => 'Configure the settings used to wrap JS blocks.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('labjs_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file path' => $file_path,
    'file' => 'labjs.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_module_implements_alter().
 */
function labjs_module_implements_alter(&$implementations, $hook) {
  // Move labjs to the top.
  if ($hook === 'advagg_modify_js_pre_render_alter' && array_key_exists('labjs', $implementations)) {
    $item = array('labjs' => $implementations['labjs']);
    unset($implementations['labjs']);
    $implementations = array_merge($item, $implementations);
  }

  // Move labjs to the bottom.
  if ($hook === 'js_alter') {
    $item = array('labjs' => $implementations['labjs']);
    unset($implementations['labjs']);
    $implementations = array_merge($implementations, $item);
  }
}

/**
 * Implements hook_js_alter().
 */
function labjs_js_alter(&$javascript) {
  // We need the jquery hold ready script to be straight after jquery.
  uasort($javascript, 'drupal_sort_css_js');
  foreach ($javascript as $filename => $script) {
    if (_labjs_file_is_jquery($filename)) {
      $path = labjs_get_jquery_hold_ready_path();
      $javascript[$path]['weight'] = $script['weight'] + 0.001;
      $javascript[$path]['scope'] = $script['scope'];
      $javascript[$path]['group'] = $script['group'];
      break;
    }
  }

  if (labjs_suppress()) {
    // We always need the lab scripts even if lab is supressed so that triggers
    // will still exist.
    _labjs_add_scripts($javascript);
    return;
  }

  if (module_exists('advagg')) {
    return;
  }

  $scripts = array();
  $files = array();
  $preprocess_js = (variable_get('preprocess_js', FALSE) && (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update'));
  // The index counter is used to keep aggregated and non-aggregated files in
  // order by weight.
  $index = 1;

  // A dummy query-string is added to filenames, to gain control over
  // browser-caching. The string changes on every update or full cache
  // flush, forcing browsers to load a new copy of the files, as the
  // URL changed. Files that should not be cached (see drupal_add_js())
  // get REQUEST_TIME as query-string instead, to enforce reload on every
  // page request.
  $default_query_string = variable_get('css_js_query_string', '0');

  // Since JavaScript may look for arguments in the URL and act on them, some
  // third-party code might require the use of a different query string.
  $js_version_string = variable_get('drupal_js_version_query_string', 'v=');

  // Sorts the scripts into correct order
  // Drupal assigns different weight for each scripts, thus we can't determine
  // if two scripts can be executed in parallel. However, they are all loaded in
  // parallel.
  uasort($javascript, 'drupal_sort_css_js');

  // Provide the page with information about the individual JavaScript files
  // used, information not otherwise available when aggregation is enabled.
  $setting['ajaxPageState']['js'] = array_fill_keys(array_keys($javascript), 1);
  unset($setting['ajaxPageState']['js']['settings']);
  drupal_add_js($setting, 'setting');

  // Get the lowest and highest JS groups and weights so scripts can be moved
  // to the start or end of all others.
  $min_max = labjs_get_js_min_max($javascript);
  foreach (array_keys($min_max) as $scope) {
    $blocks[$scope] = 0;
  }
  foreach ($javascript as $key => $item) {
    $block = &$blocks[$item['scope']];
    if (!isset($scripts[$item['scope']][$block])) {
      $scripts[$item['scope']][$block] = [
        'weight' => $min_max[$item['scope']]['min']['weight'],
        'group' => $min_max[$item['scope']]['min']['group'],
        'items' => [],
      ];
    }
    if (empty($item['inline'])) {
      if (!isset($item['type']) || $item['type'] == 'file' || $item['type'] == 'external') {
        if ($item['type'] == 'external' || !$item['preprocess'] || !$preprocess_js) {
          $query_string =  empty($item['version']) ? $default_query_string : $js_version_string . $item['version'];
          $query_string_separator = (strpos($item['data'], '?') !== FALSE) ? '&' : '?';
          $src = $item['type'] == 'external' ? $item['data'] : file_create_url($item['data']) . $query_string_separator . ($item['cache'] ? $query_string : REQUEST_TIME);
          $scripts[$item['scope']][$block]['items'][$index++] = $src;
        }
        else {
          $filekey = 'aggregate_' . $item['group'] . '_' . $item['every_page'] . '_' . $index;
          $scripts[$item['scope']][$block]['items'][$filekey] = '';
          $files[$item['scope']][$block][$filekey][$item['data']] = $item;
        }
        unset($javascript[$key]);
      }
    }
    elseif ($item['type'] == 'inline') {
      $javascript[$key]['data'] = LABJS_EXCLUDE . "\n" . $javascript[$key]['data'];
    }

    // If this is an inline script then we need to update the counters so that
    // We can split up the scripts that will be labjsified.
    if (!empty($item['inline']) || $item['type'] == 'inline') {
      $min_max[$item['scope']]['min']['weight'] = $item['weight'] + 0.001;
      $min_max[$item['scope']]['min']['group'] = $item['group'];
      $block++;
    }
  }

  // Aggregates any remaining JS files
  if ($preprocess_js && count($files) > 0) {
    foreach ($files as $scope => $blocks) {
      foreach ($blocks as $block => $items) {
        foreach ($items as $key => $file_set) {
          $uri = drupal_build_js_cache($file_set);
          // Only include the file if was written successfully. Errors are logged
          // using watchdog.
          if ($uri) {
            $scripts[$scope][$block]['items'][$key] = file_create_url($uri);
          }
        }
      }
    }
  }

  _labjs_add_scripts($javascript, $scripts);
}

/**
 * Adds the required scripts to the page.
 *
 * @param array $javascript
 *   The JS to add to.
 * @param array $scripts
 *   The scripts to add.
 */
function _labjs_add_scripts(&$javascript, $scripts = []) {
  // Adds the JS function call
  $base = array(
    'defer' => FALSE,
    'type' => 'inline',
  );
  $javascript['labjs--init'] = $base + array(
      'scope' => 'header',
      'data' => LABJS_EXCLUDE . "\nvar \$L = \$L || \$LAB.setGlobalDefaults({AlwaysPreserveOrder:true, AllowDuplicates:false});",
      'weight' => 0,
      'group' => JS_DEFAULT,
      'every_page' => TRUE,
    );
  $javascript['labjs--execute'] = $base + array(
      'scope' => 'footer',
      'data' => LABJS_EXCLUDE . "\n\$L = \$L.wait(function() {Drupal.scriptsready=true;jQuery(document).trigger('scripts-ready');});",
      'weight' => 0,
      'group' => JS_DEFAULT,
      'every_page' => TRUE,
    );
  foreach ($scripts as $scope => $blocks) {
    foreach ($blocks as $block => $data) {
      if (!$data['items']) {
        continue;
      }
      $javascript['labjs-' . $scope . '-' . $block] = $base + [
          'scope' => $scope,
          'data' => LABJS_EXCLUDE . "\n\$L = \$L.script([\"" . implode("\",\n\"", $data['items']) . "\"]).wait();",
          'weight' => $data['weight'],
          'group' => $data['group'],
          'every_page' => FALSE,
        ];
    }
  }

  $min_max = labjs_get_js_min_max($javascript);

  $javascript[labjs_get_path()]['group'] = $min_max['header']['min']['group'];
  $javascript[labjs_get_path()]['weight'] = $min_max['header']['min']['weight'] - 0.002;

  $javascript['labjs--init']['group'] = $min_max['header']['min']['group'];
  $javascript['labjs--init']['weight'] = $min_max['header']['min']['weight'] - 0.001;

  $javascript['labjs--execute']['group'] = $min_max['footer']['max']['group'] + 1;
  $javascript['labjs--execute']['weight'] = $min_max['footer']['max']['weight'] + 0.001;
}

/**
 * Gets the minimum and maximum group and weight for each JS scope.
 *
 * @param array $javascript
 *   The javascript to analyse.
 *
 * @return array
 *   A formatted array with the min and maxes for each scope.
 */
function labjs_get_js_min_max($javascript) {
  $min_max = [];

  // Separate the JS by scope.
  $scoped_js = [];
  foreach ($javascript as $script) {
    $scoped_js[$script['scope']][] = $script;
  }

  foreach ($scoped_js as $scope => $scripts) {
    uasort($scripts, 'drupal_sort_css_js');
    $first = reset($scripts);
    $last = end($scripts);

    $min_max[$scope] = [
      'min' => [
        'group' => $first['group'],
        'weight' => $first['weight'],
      ],
      'max' => [
        'group' => $last['group'],
        'weight' => $last['weight'],
      ],
    ];
  }

  return $min_max;
}

/**
 * Convert inline script.
 *
 * It also fixes some exceptions.
 *
 * @return boolean
 *   FALSE if LabJS should not be enabled, TRUE otherwise.
 */
function _labjs_fix_inline(&$value) {
  // Some JavaScripts do not support LABjs
  if (strpos($value, 'rpxnow.com') !== FALSE || strpos($value, 'fbcdn.net') !== FALSE) {
    return FALSE;
  }

  // DataLayer compatibility.
  if (module_exists('datalayer') && strpos($value, 'dataLayer') === 0) {
    return FALSE;
  }

  // Picture compatibility.
  if (module_exists('picture') && strpos($value, 'document.createElement') !== FALSE && strpos($value, 'picture') !== FALSE) {
    return FALSE;
  }

  // Google Analytics compatibility
  $value = str_replace('var _gaq = _gaq || [];', 'if (typeof(_gaq)=="undefined") _gaq=[];', $value);

  // Piwik compatibility
  $value = str_replace('var _paq = _paq || [];', 'if (typeof(_paq)=="undefined") _paq=[];', $value);

  $value = "\$L = \$L.wait(function() {\n" . $value . "\n});";

  return TRUE;
}

/**
 * Implements hook_preprocess_html_tag().
 *
 * Inline JavaScript blocks must be executed in order. In the blocking script load,
 * this is the default behavior. With LAB, we must wrap them in wait() to preserve
 * this behavior
 */
function labjs_preprocess_html_tag(&$variables) {
  if (labjs_suppress()) {
    return;
  }

  if (module_exists('advagg')) {
    return;
  }

  if ($variables['element']['#tag'] == 'script' && !empty($variables['element']['#value']) && strpos($variables['element']['#value'], LABJS_EXCLUDE) !== 0) {
    _labjs_fix_inline($variables['element']['#value']);
  }
}

// AdvAgg hook implementations.
/**
 * Implements hook_advagg_modify_js_pre_render_alter().
 */
function labjs_advagg_modify_js_pre_render_alter(&$children, &$elements) {
  if (labjs_suppress()) {
    return;
  }

  // Detect if $LAB.setGlobalDefaults is used in this scope. If it is, then set
  // $init_encountered to FALSE so the LABjs loader code doesn't get LAB-ed. If
  // it is not detected, assume the LABjs loader code will be found in another
  // scope.
  foreach ($children as $key => &$values) {
    // Do not LAB.js anything until "$LAB.setGlobalDefaults" has been seen.
    if (!empty($values['#value']) && strpos($values['#value'], '$LAB.setGlobalDefaults')) {
      $init_encountered = TRUE;
      break;
    }
  }
  if (!empty($init_encountered)) {
    $init_encountered = FALSE;
  }
  else {
    $init_encountered = TRUE;
  }

  $labjs_ready_key = FALSE;
  $drupal_settings_key = FALSE;
  foreach ($children as $key => &$values) {
    // Do not LAB.js anything until "$LAB.setGlobalDefaults" has been seen.
    if (!$init_encountered && !empty($values['#value']) && strpos($values['#value'], '$LAB.setGlobalDefaults')) {
      $init_encountered = TRUE;
    }
    if (!$init_encountered) {
      continue;
    }

    // Inline JS.
    if (!empty($values['#value']) && strpos($values['#value'], LABJS_EXCLUDE) === FALSE) {
      if (!_labjs_fix_inline($values['#value'])) {
        continue;
      }
    }

    // JS src files.
    if (!empty($values['#attributes']['src'])) {
      $values['#value'] = "\n" . LABJS_EXCLUDE . "\n" . '$L = $L.script(["' . $values['#attributes']['src'] . '"]);';
      $values['#value_prefix'] = "\n" . '<!--//--><![CDATA[//><!--';
      $values['#value_suffix'] = "\n" . '//--><!]]>';

      $values['#attributes']['src'] = NULL;
      unset($values['#attributes']['src']);
    }

    if (!empty($values['#value'])) {
      // LAB.js ready script key value.
      if (strpos($values['#value'], 'Drupal.scriptsready=true;jQuery(document).trigger("scripts-ready")') !== FALSE) {
        $labjs_ready_key = $key;
      }
      // Drupal.settings script key value.
      if (strpos($values['#value'], 'jQuery.extend(Drupal.settings') !== FALSE) {
        $drupal_settings_key = $key;
      }
    }
  }

  // If settings is in the footer, make sure trigger("scripts-ready") happens
  // after Drupal.settings has been loaded.
  if (   $labjs_ready_key !== FALSE
      && $drupal_settings_key !== FALSE
      && $labjs_ready_key < $drupal_settings_key
        ) {
    $settings = $children[$drupal_settings_key];
    $children[$drupal_settings_key] = $children[$labjs_ready_key];
    $children[$labjs_ready_key] = $settings;
  }
}

/**
 * Implements hook_advagg_js_groups_alter().
 */
function labjs_advagg_js_groups_alter(&$js_groups, $preprocess_js) {
  if (!$preprocess_js) {
    return;
  }
  $labjs_location = labjs_get_path();

  foreach ($js_groups as &$data) {
    foreach ($data['items'] as &$values) {
      if ($values['data'] == $labjs_location) {
        // Strictly enforce preprocess = FALSE for labjs.
        $values['preprocess'] = FALSE;
        $data['preprocess'] = FALSE;
        break 2;
      }
    }
  }
}

/**
 * Helper for search for LAB.min.js file.
 *
 * If our system does not have libraries module, that file must reside at
 * sites/all/libraries/labjs/LAB.min.js.
 * If Libraries API is available, there are more choices.
 */
function labjs_get_path() {
  return drupal_get_path('module', 'labjs') . '/labjs.min.js';
}

/**
 * Disable LABjs for the current page.
 *
 * This function should be called from within another module's page callback
 * (preferably using module_invoke()) when the taskbar should not be enabled.
 * This is useful for modules that implement popup pages or other special
 * pages where LABjs could break the layout.
 *
 * @param $set
 *   If FALSE is passed, the suppression state is returned.
 */
function labjs_suppress($set = FALSE) {
  static $suppress;

  if ($set) {
    $suppress = TRUE;
  }
  elseif (!isset($suppress)) {
    // First, check the global enable settings and the maintenance mode,
    // we should disable LABjs in those cases.
    $suppress = !variable_get('labjs_enabled', TRUE) || defined('MAINTENANCE_MODE');

    // Match path if necessary
    if (!$suppress && $pages = variable_get('labjs_pages_list', '')) {
      $path = drupal_get_path_alias($_GET['q']);
      // Compare with the internal and path alias (if any).
      $page_match = drupal_match_path($path, $pages);
      if ($path != $_GET['q']) {
        $page_match = $page_match || drupal_match_path($_GET['q'], $pages);
      }
      $suppress = (variable_get('labjs_pages_choice', 0) xor $page_match);
    }
  }

  return $suppress;
}

/**
 * Implements hook_page_delivery_callback_alter().
 *
 * It's too late to call labjs_suppress(). We have no choice but create our own callback.
 */
function labjs_page_delivery_callback_alter(&$callback) {
  if (module_exists('overlay') && overlay_display_empty_page() && !labjs_suppress()) {
    $callback = 'labjs_deliver_empty_page';
  }
}

/**
 * Delivery callback to display an empty page.
 *
 * This function is used to print out a bare minimum empty page which still has
 * the scripts and styles necessary in order to trigger the overlay to close.
 * Clone from overlay_deliver_empty_page with LABjs enabled.
 */
function labjs_deliver_empty_page() {
  $empty_page = '<html><head><title></title>' . drupal_get_css() . drupal_get_js() . '</head><body class="overlay"><script>$L = $L.wait(function() {Drupal.scriptsready=true;jQuery(document).trigger("scripts-ready");});</script></body></html>';
  print $empty_page;
  drupal_exit();
}

/**
 * Function to determine if the filename is a path for jQuery.
 *
 * @param string $filename
 *   The filename to check.
 *
 * @return bool
 *   Whether or not this is jQuery
 */
function _labjs_file_is_jquery($filename) {
  $jquery_filename = '/jquery.min.js';

  // The jquery filename should appear at the end of the string.
  $position = strlen($filename) - strlen($jquery_filename);
  return strpos($filename, $jquery_filename) === $position;
}

/**
 * Gets the path for the jQuery hold ready script.
 *
 * @return string
 *   The path to the jQuery hold ready script.
 */
function labjs_get_jquery_hold_ready_path() {
  return drupal_get_path('module', 'labjs') . '/labjs-jquery-hold-ready.js';
}
